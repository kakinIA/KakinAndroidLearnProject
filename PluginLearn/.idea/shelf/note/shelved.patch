Index: readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## 插件化\r\n### 内容\r\n1. 概述\r\n2. 原理\r\n\r\n### 概述\r\n#### 含义\r\nAndroid的插件化通常指一个宿主apk管理多个插件,每个插件是一个独立的apk。它适合宿主APK和插件APK分开打包，有效减少宿主APK文件过大，便于拓展业务。\r\n\r\n#### 优点\r\n* 宿主和插件分开编译，插件app编译好后放到宿主app使用，做到并发开发。\r\n* 插件可动态更新使用，独立于宿主的版本开发之外。\r\n* 解决方法数、变量数爆棚问题。\r\n\r\n#### 难点\r\n* 插件四大组件使用。\r\n* 插件四大组件生命周期、回调管理。\r\n\r\n### 原理\r\n#### 为什么插件是一个apk？\r\n插件所具备的功能是可以显示一个独立的完整界面，那么显示这个界面肯定需要逻辑代码和资源，这时候应该可以想到从类加载器ClassLoader和资源Resource出发，所以插件包里的dex文件和res都是需要的，而apk正是具备这些东西。    \r\n\r\nClassLoder可以通过apk文件DexClassLoader获取，而Resource可以通过AssetManager获取\r\n>> PluginManager#loadPath\r\n```\r\n    fun loadPath(context: Context, pluginFileName: String, isRefresh: Boolean = true) {\r\n        val filesDir = context.getDir(FOLDER_NAME_PLUGIN, Context.MODE_PRIVATE)\r\n        val pluginFile = File(filesDir, pluginFileName)\r\n        val pluginPath = pluginFile.absolutePath\r\n        val dexOutFile = context.getDir(FOLDER_NAME_DEX, Context.MODE_PRIVATE)\r\n\r\n        if (isRefresh) {\r\n            //先删除，做更新\r\n            if (pluginFile.exists()) {\r\n                pluginFile.delete()\r\n            }\r\n            obtainPluginFile(context, pluginFileName, pluginFile)\r\n        } else {\r\n            if (!pluginFile.exists()) {\r\n                obtainPluginFile(context, pluginFileName, pluginFile)\r\n            }\r\n        }\r\n\r\n        val dexClassLoader =\r\n            DexClassLoader(pluginPath, dexOutFile.absolutePath, null, context.classLoader)\r\n\r\n        Log.d(TAG, \"pluginPath: $pluginPath, \\ndexOutFile: $dexOutFile\")\r\n\r\n        try {\r\n            val assetManager = AssetManager::class.java.newInstance()\r\n            val addAssetPath =\r\n                AssetManager::class.java.getMethod(\"addAssetPath\", String::class.java)\r\n            addAssetPath.invoke(assetManager, pluginPath)\r\n            val resources = Resources(\r\n                assetManager,\r\n                context.resources.displayMetrics,\r\n                context.resources.configuration\r\n            )\r\n            mPluginInfoMap[pluginFileName] =\r\n                PluginInfo(context, pluginFileName, dexClassLoader, resources, pluginPath)\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n\r\n        parseReceivers(context, pluginPath, dexClassLoader)\r\n    }\r\n```\r\n#### 怎么使用插件的四大组件？\r\n可以采用插桩的形式。即跳转的四大组件是宿主的四大组件，但逻辑使用的是插件的内容。因此需要定义一个标准接口，接口的内容至少需要具备activity的生命周期[IPluginActivit.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/standard/IPluginActivity.kt),在宿主里调用这个接口[ProxyPluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/proxy/ProxyPluginActivity.kt),在插件中实现这个接口[BasePluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/base/BasePluginActivity.kt),并且注意activity的context，用到context的地方都需要换成宿主的context\r\n\r\n#### 细化分析\r\n##### 应用包APK\r\nAPK为AndroidApackage缩写    \r\n\r\nAndroid应用四种安装方式\r\n1. 已安装的系统应用安装其它应用。特点：无安装界面，直接安装。\r\n2. 手机应用市场安装apk。特点：有安装界面\r\n3. ADB工具安装。特点：无安装界面\r\n4. 第三方应用，点击安装。特点：有安装界面，由PackageInstaller.apk应用处理安装及卸载过程的界面    \r\n\r\n安装时系统做的事情\r\n1. 将apk文件复制到data/app\r\n2. 创建存放应用文件的数据 /data/data/包名\r\n3. 将apk中的dex文件安装到data/dalvik-cache目录下（dex：dalvik虚拟机的可执行文件）\r\n\r\n静态广播\r\n* 静态广播的注册是在应用安装后或系统启动后注册，在应用层中静态广播的注册方式是在AndroidManifest中注册，系统具体如何在注册静态广播，可以定位到PMS（PackageManagerService.java）中。\r\n* PMS（PackageManagerService）应用程序管理服务，会扫描系统中的一些路径，其中包括了已安装应用的路径，扫描的时候会解析应用中的AndroidManifest，获得广播并注册。   \r\n\r\n>> PMS扫描并解析源码定位 sdk23\r\n>> 构造函数中scanDirLI(mAppInstallDir, 0, scanFlags, 0); //扫描安装目录\r\n>> scanPackageLI //扫描包方法，获取PackageParser.Package类，可以看到这个类里面的成员变量\r\n\r\n**重点分析PackageParser**这个类，这是一个包解析的类，这是系统源码，以下都是以==Android6.0==为准，因此在实际开发中需要注意版本兼容\r\n\r\n>> PackageParser#parsePackage是解析包的方法，逻辑会进入PackageParser#parseApkLite中，parseApkLite会对AndroidManifest进行解析\r\n```\r\n    /**\r\n     * Utility method that retrieves lightweight details about a single APK\r\n     * file, including package name, split name, and install location.\r\n     *\r\n     * @param apkFile path to a single APK\r\n     * @param flags optional parse flags, such as\r\n     *            {@link #PARSE_COLLECT_CERTIFICATES}\r\n     */\r\n    public static ApkLite parseApkLite(File apkFile, int flags)\r\n            throws PackageParserException {\r\n        final String apkPath = apkFile.getAbsolutePath();\r\n\r\n        AssetManager assets = null;\r\n        XmlResourceParser parser = null;\r\n        try {\r\n            assets = new AssetManager();\r\n            assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n                    Build.VERSION.RESOURCES_SDK_INT);\r\n\r\n            int cookie = assets.addAssetPath(apkPath);\r\n            if (cookie == 0) {\r\n                throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,\r\n                        \"Failed to parse \" + apkPath);\r\n            }\r\n\r\n            final DisplayMetrics metrics = new DisplayMetrics();\r\n            metrics.setToDefaults();\r\n\r\n            final Resources res = new Resources(assets, metrics, null);\r\n            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);\r\n\r\n            final Signature[] signatures;\r\n            if ((flags & PARSE_COLLECT_CERTIFICATES) != 0) {\r\n                // TODO: factor signature related items out of Package object\r\n                final Package tempPkg = new Package(null);\r\n                collectCertificates(tempPkg, apkFile, 0);\r\n                signatures = tempPkg.mSignatures;\r\n            } else {\r\n                signatures = null;\r\n            }\r\n\r\n            final AttributeSet attrs = parser;\r\n            return parseApkLite(apkPath, res, parser, attrs, flags, signatures);\r\n\r\n        } catch (XmlPullParserException | IOException | RuntimeException e) {\r\n            throw new PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION,\r\n                    \"Failed to parse \" + apkPath, e);\r\n        } finally {\r\n            IoUtils.closeQuietly(parser);\r\n            IoUtils.closeQuietly(assets);\r\n        }\r\n    }\r\n```\r\n>>PackageParser.Package 部分源码\r\n\r\n    /**\r\n     * Representation of a full package parsed from APK files on disk. A package\r\n     * consists of a single base APK, and zero or more split APKs.\r\n     */\r\n    public final static class Package {\r\n        // For now we only support one application per package.\r\n        public final ApplicationInfo applicationInfo = new ApplicationInfo();\r\n\r\n        public final ArrayList<Permission> permissions = new ArrayList<Permission>(0);\r\n        public final ArrayList<PermissionGroup> permissionGroups = new ArrayList<PermissionGroup>(0);\r\n        public final ArrayList<Activity> activities = new ArrayList<Activity>(0);\r\n        public final ArrayList<Activity> receivers = new ArrayList<Activity>(0);\r\n        public final ArrayList<Provider> providers = new ArrayList<Provider>(0);\r\n        public final ArrayList<Service> services = new ArrayList<Service>(0);\r\n        public final ArrayList<Instrumentation> instrumentation = new ArrayList<Instrumentation>(0);\r\n\r\n    }\r\n\r\n在PackageParser.Package的源码中可以容易看出AndroidManifest.xml中注册四大组件转成java的变量receivers显然就是广播，它是Activity的集合，这里的activity不是组件的activity。它里面包含了类名、IntentFilter，通过这两个东西，我们可以在插件启动的过程中动态注册广播接收者，详细可参考==PluginManager#parseReceivers==\r\n\r\n### 参考\r\n[Android插件化技术调研](https://www.cnblogs.com/tgltt/p/9542193.html)\r\n\r\n### 其它\r\n[本项目](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/tree/master/PluginLearn)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- readme.md	(revision e73693a0cbbe3deb54cee519cb51f1ea017b6e51)
+++ readme.md	(date 1569255645240)
@@ -13,13 +13,23 @@
 * 解决方法数、变量数爆棚问题。
 
 #### 难点
+* 版本兼容
+插件针对以下两个方向（插桩、Hook）有它们着重的点。
+##### 插桩方式
 * 插件四大组件使用。
 * 插件四大组件生命周期、回调管理。
 
+##### Hook方式
+* Hook点，特别是对AMS（ActivityManagerService）、PMS(PackageManagerService)的理解
+
+
 ### 原理
 #### 为什么插件是一个apk？
 插件所具备的功能是可以显示一个独立的完整界面，那么显示这个界面肯定需要逻辑代码和资源，这时候应该可以想到从类加载器ClassLoader和资源Resource出发，所以插件包里的dex文件和res都是需要的，而apk正是具备这些东西。    
 
+#### 插桩方式
+可以采用插桩的形式。即跳转的四大组件是宿主的四大组件，但逻辑使用的是插件的内容。因此需要定义一个标准接口，接口的内容至少需要具备activity的生命周期[IPluginActivit.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/standard/IPluginActivity.kt),在宿主里调用这个接口[ProxyPluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/proxy/ProxyPluginActivity.kt),在插件中实现这个接口[BasePluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/base/BasePluginActivity.kt),并且注意activity的context，用到context的地方都需要换成宿主的context    
+
 ClassLoder可以通过apk文件DexClassLoader获取，而Resource可以通过AssetManager获取
 >> PluginManager#loadPath
 ```
@@ -65,8 +75,6 @@
         parseReceivers(context, pluginPath, dexClassLoader)
     }
 ```
-#### 怎么使用插件的四大组件？
-可以采用插桩的形式。即跳转的四大组件是宿主的四大组件，但逻辑使用的是插件的内容。因此需要定义一个标准接口，接口的内容至少需要具备activity的生命周期[IPluginActivit.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/standard/IPluginActivity.kt),在宿主里调用这个接口[ProxyPluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/proxy/ProxyPluginActivity.kt),在插件中实现这个接口[BasePluginActivity.kt](https://github.com/kakinIA/KakinAndroidLearnProject-Lib/blob/master/PluginLearn/plugin-lib/src/main/java/com/kakin/learn/plugin_lib/base/BasePluginActivity.kt),并且注意activity的context，用到context的地方都需要换成宿主的context
 
 #### 细化分析
 ##### 应用包APK
